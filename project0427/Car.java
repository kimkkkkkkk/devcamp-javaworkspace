/*자동차를 정의해본다*/
class Car{
	String name="벤츠"; // 이 변수들이 메모리에 올라가는 타이밍은 거푸집으로 부터 new 한 순간에 올라감
	int price=9000; // 클래스가 보유한 멤버변수
	String color="black";//메모리에 올라간 것을 인스턴스라 하고 인스턴스 스스로는 나(this)라 함.

	public void setPrice(int price){ //함수의 매개변수 넣어줘야 함
		this.price=price;
	}

	public static void main(String[] args){
		Car c1 = new Car();
		Car c2 = new Car();
		Car c3 = c2; //현재 jvm에 올라간 자동차는 2대 c3에 속지 말것 c3-> c2를 가리킴
		
		c1.setPrice(8000); // 첫번째 자동차의 가격을 8천으로 내림
		System.out.println(c2.price); // 두번째 자동차가 영향을 받았는지 여부를 체크
		//결론: 메모리에 올라간 인스턴스들은 서로 다른 별개의 객체들이다.

		c3.setPrice(7000); // c2가 가리키고 있었던 자동차와 동일한 위치의 차를 가리키므로
		// 즉 두번째 자동차의 가격을 7000으로 변경하게 됨
		System.out.println(c2.price);
	}
}
//차가 하드디스크에 올라 와있고 컴파일 한 순간 기계언어로 바뀌고
// static에 저 원본코드들이 들어감 클래스가 load된 것
//실행한 순간 메모리 대상으로한 코드들이 실행부가 메인 메서드를 호출한다
//public static 부분 실행 
//그러면 c1이라는 지역변수가 stack에 쌓임
//stack의 밑 바닥에 들어오고 공간이 만들어짐 
//카라고 불리는 코드 영역이 heap으로 가면서 new가 되고 heap에서 자동차 메모리가 만들어짐
//heap 자동차 메모리안에는 컬러, 가격, 이름이 그대로 딸려 올라감 (멤버변수, 멤버 메서드)
//new 에 의해서 딸려 온 것들을 인스턴스 변수, 인스턴스 메서드라고 함
//그리고 c1은 뭘가르키냐 heap 자동차를 @로해서 갖고 잇음
//그리고 두번째 자동차 똑같이 ... 그러고 c1 위로 올라옴..
//------------c3부분--------------------------------
//c3라는 지역변수가 스택에 싸임 얘는 c2라는 변수값을 가리킴
//두번쨰 자동차를 가리키는 주소값을 똑같이 가리키면 됨
