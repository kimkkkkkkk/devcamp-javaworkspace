/*자료형과 관련된 학습 연장할 꺼임*/
class TypeTest1{
	public static void main(String[] args){
	/*byte: short:2 int:4 long:8 float:4 double:8 char:2 boolean:1*/
		byte b=5; //1byte
		short s=8; //2byte
		// s=b; // O 작--> 큰 들어가는건 당연히 가능
		//b=s; // X 큰--> 작 들어가려니 데이터의 손실 발생
		/*아래의 코드가 컴파일 에러가 발생하는 이유는?
		고전적인 C언어를 포함하여, 현대의 컴퓨터 언어에 이르기까지
		정수의 연산은 int를 기준으로 최적화되어 있기 때문에, 연산시
		int이하의 자료형들은 컴파일러에 의해 자동으로 자료형으로 int형으로 변환
		해 버린다.. 이러한 현상을 개발자가 의해서가 아니라 시스템에 의한
		형변환이므로,, '자동형변환' 이라 한다.
		참고) 왜 int 이하만 적용되는 이유는? 손실을 발생시키면서까지 속도를 올릴이유는 없다.
		*/
		short s1=8;
		short s2=9;
		//short result = s1+s2;  // +연산을 수행하기전에 시스템이 s1,s2를
		//				↓				int로 변환한 후, 연산을 수행한다!!
		short result = (short)(s1+s2);
		//에러가 안 나게 하는 법?
		//해결책1) short result를 int result 로 선언한다!!
		//해결책2) 개발자가 손실을 감안하고, 그대로 강경하게 밀어붙임..
		//			->	강제 형변환이라 한다, 이때 (자료형) 소괄호를 cast 연산자라 한다.
		//			cast : 연예인들 casting 당할때 그거랑 같다고 생각하면됨
		long x=65;
		int k=78;
		//int result2 = x+k; // X -> int형 이하의 자료형은 자동으로 자료형을 int형으로 자동형변환
								// 롱은 인트보다 커서 자동형변환이 안 된다
		// 컴파일러가 연산을 수행할때는 연산 대상이 되는 데이터는 무조건 같은
		// 큰자료형으로 수형을 맞추고 나서 수행한다!! 이때 데이터 손실이 발생하지 않도록
		// 큰 자료형을 기준으로 형변환된다!!
		//long result2 = x+k;
		//int result2 = (int)(x+k); 손실감안하면서까지 int로 강제 형변환
	
	}
}