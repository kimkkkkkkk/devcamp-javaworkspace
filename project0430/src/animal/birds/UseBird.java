package animal.birds;
/*
상속에서 놓치지 말아야 할 핵심 주제
1) 코드의 재사용
2) 객체간 형변환( 시험 단골 메뉴)
*/
class UseBird{
	public static void main(String[] args){
		int x=7; //4 byte
		byte b=3; //1 byte
		//x=b; //가능한 코드
		b=(byte)x; // 불가능, 손실이 발생하므로, 불가능하다.. 하지만 개발자가 손실을 감안해서라도
				//강제로 형변환을 명시하면 인정해준다..b=(응)x; ->이때 강제형변환이라고 하고 (소괄호)를 가리켜 캐스트 연산자라 한다..

		//객체 자료형의 형변환의 예
		Bird bird = new Bird("red");
		Duck d = new Duck("white");
		bird=d; // O X 
		//버드가 덕보다 용량이 크다는 것을 기본자료형에 비추어 용량의 문제로 접근하면 안됨..
		//객체 자료형은 누가 용량이크다 작다고 얘기 하면 안됨
		//객체 자료형에서의 판단기준은 상위 하위로 접근해야한다.
		//객체간 형변환은 누가 더 폭넒은 객체를 가리 킬 수 있느냐? 상위 자료형이다.. 큰 자료형..
		//피라미드 구조 생각하자 위로 올라갈 수로 상위기준	 오리 -> 새 -> 동물 -> 생물
		//재산은 밑으로 내려갈 수록 커짐 부의 상속..내재산 +부모재산
		//상위는 상당히 많은 걸 가리킬 수 있다 (폭 넓은 데이터를 가리킬 수 있다)
		// bird가 용량이 커서 Duck을 가리킬 수 있다는게 아니라 bird가 상위개념이어서 bird를 가리킬 수 있다
		
		bird.fly();
		//bird.canSwim(); // bird 변수의 자료형은 Bird이기 때문에 당연히 Bird 클래스에는
							  // canSwim() 메서드가 없다!! 따라서 컴파일 에러!!

		// 객체도 강제형변환이 된다 왔다갔다 하면 됨! 
		// 이때 자식 자료형으로의 형변환을 가리켜 downCasting이라 한다..
		Duck duck=(Duck)bird; //오른쪽은 상위 왼쪽은 하위
		duck.canSwim(); // 

	}
}